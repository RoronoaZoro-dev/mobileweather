import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:fl_chart/fl_chart.dart';
import '../provider/weather_provider.dart';
import '../utils/date_utils.dart';

class AnalysisScreen extends StatelessWidget {
  const AnalysisScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final provider = Provider.of<WeatherProvider>(context);
    final data = provider.weatherData;
    final past = provider.pastData;

    if (data == null || data['daily'] == null || data['daily'].isEmpty) {
      return const Scaffold(
        body: Center(child: Text('No weather data available yet.')),
      );
    }

    final futureDays = data['daily'];
    final pastTemps = past.take(7).map((e) => e['current']?['temp'] ?? 0.0).toList().reversed.toList();
    final pastLabels = past.take(7).map((e) => formatDate(e['dt'] as int)).toList().reversed.toList();
    final futureTemps = List.generate(7, (i) => (futureDays[i]['temp']['day'] as num).toDouble());
    final futureHumidity = List.generate(7, (i) => (futureDays[i]['humidity'] as num).toDouble());
    final futureLabels = List.generate(7, (i) => formatDate(futureDays[i]['dt'] as int));

    // Temperature averages
    final avgPast = pastTemps.isNotEmpty ? pastTemps.reduce((a, b) => a + b) / pastTemps.length : 0;
    final avgFuture = futureTemps.isNotEmpty ? futureTemps.reduce((a, b) => a + b) / futureTemps.length : 0;

    // Warmest & coldest days
    final warmestDay = futureDays.reduce((a, b) =>
        (a['temp']['day'] as num) > (b['temp']['day'] as num) ? a : b);
    final coldestDay = futureDays.reduce((a, b) =>
        (a['temp']['day'] as num) < (b['temp']['day'] as num) ? a : b);

    // Weather condition analysis
    final conditionCount = {'Sunny': 0, 'Cloudy': 0, 'Rainy': 0};
    for (var d in futureDays) {
      final main = (d['weather'][0]['main'] ?? '').toString().toLowerCase();
      if (main.contains('rain')) {
        conditionCount['Rainy'] = conditionCount['Rainy']! + 1;
      } else if (main.contains('cloud')) {
        conditionCount['Cloudy'] = conditionCount['Cloudy']! + 1;
      } else {
        conditionCount['Sunny'] = conditionCount['Sunny']! + 1;
      }
    }

    final totalDays = futureDays.length.toDouble();
    final pieSections = conditionCount.entries.map((entry) {
      final percent = (entry.value / totalDays) * 100;
      Color color;
      switch (entry.key) {
        case 'Rainy':
          color = Colors.blueAccent;
          break;
        case 'Cloudy':
          color = Colors.grey;
          break;
        default:
          color = Colors.orangeAccent;
      }
      return PieChartSectionData(
        color: color,
        value: entry.value.toDouble(),
        title: '${entry.key}\n${percent.toStringAsFixed(0)}%',
        radius: 60,
        titleStyle: const TextStyle(color: Colors.white, fontSize: 12),
      );
    }).toList();

    return Scaffold(
      appBar: AppBar(title: const Text('Weather Analysis')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          // -------------------- TEMPERATURE TREND --------------------
          Text('Temperature Comparison',
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          SizedBox(
            height: 250,
            child: LineChart(LineChartData(
              titlesData: FlTitlesData(
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    getTitlesWidget: (v, meta) {
                      final idx = v.toInt();
                      if (idx >= 0 && idx < futureLabels.length) {
                        return Text(futureLabels[idx],
                            style: const TextStyle(fontSize: 10));
                      }
                      return const SizedBox();
                    },
                  ),
                ),
                leftTitles: AxisTitles(sideTitles: SideTitles(showTitles: true)),
              ),
              lineBarsData: [
                LineChartBarData(
                  spots: List.generate(
                      pastTemps.length, (i) => FlSpot(i.toDouble(), pastTemps[i])),
                  color: Colors.orange,
                  barWidth: 3,
                  isCurved: true,
                  dotData: FlDotData(show: false),
                ),
                LineChartBarData(
                  spots: List.generate(
                      futureTemps.length, (i) => FlSpot(i.toDouble(), futureTemps[i])),
                  color: Colors.blue,
                  barWidth: 3,
                  isCurved: true,
                  dotData: FlDotData(show: false),
                ),
              ],
            )),
          ),
          const SizedBox(height: 12),
          Text(
            'Avg past week: ${avgPast.toStringAsFixed(1)}°C | '
            'Avg next week: ${avgFuture.toStringAsFixed(1)}°C',
            style: const TextStyle(fontSize: 15),
          ),
          const SizedBox(height: 20),

          // -------------------- HUMIDITY TREND --------------------
          Text('Humidity Trend (Next 7 Days)',
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          SizedBox(
            height: 250,
            child: LineChart(LineChartData(
              titlesData: FlTitlesData(
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    getTitlesWidget: (v, meta) {
                      final idx = v.toInt();
                      if (idx >= 0 && idx < futureLabels.length) {
                        return Text(futureLabels[idx],
                            style: const TextStyle(fontSize: 10));
                      }
                      return const SizedBox();
                    },
                  ),
                ),
                leftTitles: AxisTitles(sideTitles: SideTitles(showTitles: true)),
              ),
              lineBarsData: [
                LineChartBarData(
                  spots: List.generate(
                      futureHumidity.length, (i) => FlSpot(i.toDouble(), futureHumidity[i])),
                  color: Colors.green,
                  barWidth: 3,
                  isCurved: true,
                  dotData: FlDotData(show: false),
                ),
              ],
            )),
          ),
          const SizedBox(height: 20),

          // -------------------- RAIN PROBABILITY --------------------
          Text('Rain Probability (Next 7 Days)',
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          SizedBox(
            height: 220,
            child: BarChart(BarChartData(
              alignment: BarChartAlignment.spaceAround,
              barGroups: List.generate(futureDays.length, (i) {
                final rain = (futureDays[i]['pop'] ?? 0) * 100;
                return BarChartGroupData(x: i, barRods: [
                  BarChartRodData(
                      toY: rain.toDouble(), width: 16, color: Colors.lightBlueAccent)
                ]);
              }),
              titlesData: FlTitlesData(
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    getTitlesWidget: (v, meta) {
                      final idx = v.toInt();
                      if (idx >= 0 && idx < futureLabels.length) {
                        return Text(futureLabels[idx],
                            style: const TextStyle(fontSize: 10));
                      }
                      return const SizedBox();
                    },
                  ),
                ),
              ),
            )),
          ),
          const SizedBox(height: 20),

          // -------------------- WEATHER CONDITION PIE --------------------
          Text('Weather Condition Share (Next 7 Days)',
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          Center(
            child: SizedBox(
              height: 250,
              child: PieChart(PieChartData(
                sectionsSpace: 2,
                centerSpaceRadius: 40,
                sections: pieSections,
              )),
            ),
          ),
          const SizedBox(height: 20),

          // -------------------- SUMMARY --------------------
          Text('Summary', style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(12.0),
              child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
                Text('Warmest upcoming day: ${formatDate(warmestDay['dt'])} '
                    '(${(warmestDay['temp']['day'] as num).toStringAsFixed(1)}°C)'),
                Text('Coldest upcoming day: ${formatDate(coldestDay['dt'])} '
                    '(${(coldestDay['temp']['day'] as num).toStringAsFixed(1)}°C)'),
                Text('Temperature difference: ${(avgFuture - avgPast).toStringAsFixed(1)}°C'),
                Text('Dominant condition: ${_findDominant(conditionCount)}'),
              ]),
            ),
          ),
        ]),
      ),
    );
  }

  String _findDominant(Map<String, int> map) {
    var maxKey = map.keys.first;
    for (var k in map.keys) {
      if (map[k]! > map[maxKey]!) maxKey = k;
    }
    return maxKey;
  }
}
