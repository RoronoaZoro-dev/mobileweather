import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:fl_chart/fl_chart.dart';
import '../provider/weather_provider.dart';
import '../utils/date_utils.dart';

class AnalysisScreen extends StatelessWidget {
  const AnalysisScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final provider = Provider.of<WeatherProvider>(context);
    final data = provider.weatherData;
    final past = provider.pastData;

    if (data == null || data['daily'] == null || data['daily'].isEmpty) {
      return const Scaffold(
        body: Center(child: Text('No weather data available yet.')),
      );
    }

    final futureDays = data['daily'];
    final pastTemps = past.take(7).map((e) => e['current']?['temp'] ?? 0.0).toList().reversed.toList();
    final pastLabels = past.take(7).map((e) => formatDate(e['dt'] as int)).toList().reversed.toList();
    final futureTemps = List.generate(7, (i) => (futureDays[i]['temp']['day'] as num).toDouble());
    final futureLabels = List.generate(7, (i) => formatDate(futureDays[i]['dt'] as int));

    final avgPast = pastTemps.isNotEmpty ? pastTemps.reduce((a, b) => a + b) / pastTemps.length : 0;
    final avgFuture = futureTemps.isNotEmpty ? futureTemps.reduce((a, b) => a + b) / futureTemps.length : 0;

    final warmestDay = futureDays.reduce((a, b) =>
        (a['temp']['day'] as num) > (b['temp']['day'] as num) ? a : b);
    final coldestDay = futureDays.reduce((a, b) =>
        (a['temp']['day'] as num) < (b['temp']['day'] as num) ? a : b);

    return Scaffold(
      appBar: AppBar(title: const Text('Weather Analysis')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          Text('Temperature Comparison',
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          SizedBox(
            height: 250,
            child: LineChart(LineChartData(
              titlesData: FlTitlesData(
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    getTitlesWidget: (v, meta) {
                      final idx = v.toInt();
                      if (idx >= 0 && idx < futureLabels.length) {
                        return Text(futureLabels[idx], style: const TextStyle(fontSize: 10));
                      }
                      return const SizedBox();
                    },
                  ),
                ),
                leftTitles: AxisTitles(sideTitles: SideTitles(showTitles: true)),
              ),
              lineBarsData: [
                LineChartBarData(
                  spots: List.generate(
                      pastTemps.length, (i) => FlSpot(i.toDouble(), pastTemps[i])),
                  color: Colors.orange,
                  barWidth: 3,
                  isCurved: true,
                  dotData: FlDotData(show: false),
                ),
                LineChartBarData(
                  spots: List.generate(
                      futureTemps.length, (i) => FlSpot(i.toDouble(), futureTemps[i])),
                  color: Colors.blue,
                  barWidth: 3,
                  isCurved: true,
                  dotData: FlDotData(show: false),
                ),
              ],
            )),
          ),
          const SizedBox(height: 12),
          Text(
              'Avg past week: ${avgPast.toStringAsFixed(1)}°C | Avg next week: ${avgFuture.toStringAsFixed(1)}°C',
              style: const TextStyle(fontSize: 15)),
          const SizedBox(height: 20),
          Text('Rain Probability (Next 7 Days)',
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          SizedBox(
            height: 220,
            child: BarChart(BarChartData(
              alignment: BarChartAlignment.spaceAround,
              barGroups: List.generate(futureDays.length, (i) {
                final rain = (futureDays[i]['pop'] ?? 0) * 100;
                return BarChartGroupData(x: i, barRods: [
                  BarChartRodData(
                      toY: rain.toDouble(),
                      width: 16,
                      color: Colors.blueAccent)
                ]);
              }),
              titlesData: FlTitlesData(
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                      showTitles: true,
                      getTitlesWidget: (v, meta) {
                        final idx = v.toInt();
                        if (idx >= 0 && idx < futureLabels.length) {
                          return Text(futureLabels[idx], style: const TextStyle(fontSize: 10));
                        }
                        return const SizedBox();
                      }),
                ),
              ),
            )),
          ),
          const SizedBox(height: 20),
          Text('Summary',
              style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 8),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(12.0),
              child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
                Text('Warmest upcoming day: ${formatDate(warmestDay['dt'])} '
                    '(${(warmestDay['temp']['day'] as num).toStringAsFixed(1)}°C)'),
                Text('Coldest upcoming day: ${formatDate(coldestDay['dt'])} '
                    '(${(coldestDay['temp']['day'] as num).toStringAsFixed(1)}°C)'),
                Text('Temp difference: ${(avgFuture - avgPast).toStringAsFixed(1)}°C'),
              ]),
            ),
          ),
        ]),
      ),
    );
  }
}
